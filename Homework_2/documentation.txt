Функцията validate_filename() валидира, че първият позиционен параметър, който е подаден е обикновен файл и че съществува.
Функцията validate_callsign() валидира, че втория позиционен параметър, който е подаден е позивна във валиден формат, а именно поредица от главни латинцки букви, цифри и наклонени черти(\).
Функцията find_pattern() приема като първи параметър име на файл, в който да търси и като втори параметър позивна, за която да търси. Работата на тази функция е да намира най-дългия префикс от подадената позивна, който съвпада с някое правило. Използва се когато няма правило от типа =<позивна> ( тип 1) и се налага търсене на правило от тип 2(най-дълъг съвпадащ префикс). Начина, по който работи функцията е, че създава два временни файла и в първия(tempfile1) поставя всички правила от 10тата колона на файла, като има само по едно правило на ред. След това в променливата length запазвам дължината на позивната и я увеличавам с едно, за да може в случай на неуспешно намиране на правило, което еднозначно да отговаря на позивната да може да излезем от цикъла. В променливата matches пазя колко правила отговарят на дадената част от позивната и когато matches стане равно на 1 сме намерили равилото, което еднозначно да отговаря на позивната. В проеменливата i пазя колко символа от началото на стринга за позивната сме взели. Започваме с i=1 и при всяка итерация в цикъла го инкрементираме с 1. Така знаем, че ако i e нечетно четем от tempfile1 и записваме в tempfile2 и обратно. Ако i стане по-голямо от length, знаем че сме обходили цялата дължжина на стринга на позивната и излизаме от цикъла. За всяка добавена буква от стринга итерираме с grep и записваме в някой от двата временни файла по описаната горе логика и актуализираме стойността на matches, като броим редовете в новозаписания файл. Когато излезем от цикъла декрементираме i с едно и в pattern записваме най-дългия намерен префикс от позивната, на когото да отговаря правило. След това изтриваме двата временни файла.
Функцията find_line() приема като първи параметър име на файл, в който да търси и като втори параметър позивна, за която да търси. Работата на тази функция е да намира реда, на когото се намира правилото, което отговаря на позивната. Първо се проверява за правило от тип 1(=<позивна>), ако е неуспешно се позва функцията find_pattern() и и резултата от нея се запазва в локалната променлива pattern(различна от променливата pattern във функцията find_pattern()). След това с grep и регулярен израз, който покзва, че преди pattern може да има или space или запетая и след него - space, ";", защото може да е последна на реда, "(" или "[", защото може да има дефинирани допълнителни ITU зона или WAZ зона. Връща стойността на променливата line, която е намерения ред.
Функциите sin() и cos(), както и arccos() приемат един параметър - число в градуси и пресмятат съответно sin,cos и arccos. 
Функцията diff() приема две числа, които може да са положителни или отрицателни и намира абсолютната разлика на двете, като прави проверки за това дали и двете са положителни или отрицателни или първото е положително а второто отрицателно и обратно.

След всички функции започва главния код, с това че проверява броя на позиционните аргументи.
Ако са три проверява дали първия е валиден файл чрез командата validate_filename и ако не е извежда съобщението "Invalid filename\n" на stderr и терминира програмата с exit code 1. След това проверява дали вторият позиционен параметър е валидна команда ( "country" или "zones" ) и ако не е извежда съобщението "Invalid subcommand\n"  на stderr и терминира програмата с exit code 1. След това проверява дали третия позиционен параметър е валидна позивна чрез командата validate_callsign и ако не е извежда съобщението "Invalid callsign\n" на stderr и терминира програмата с exit code 1. След като всички аргументи са валидирани чрез командата find_line намира реда, на който се намира правилото, което еднозначно отговаря на позивната в променливата callsign и я присвоява на променливара line. Ако line е с дължина 0, извежда съобщението "no matches\n" на stderr и терминира програмата с exit code 1. Ако не е, проверява ако командата е "country" извежда на strout стойността на 2та колона от реда, където е името на държавата, за която е валидно това правилои следователно позивната е от тази област. Ако командата е "zones" създаваме временен файл, чието име е в променливата tempzones и в него записваме 10-тата колона от стойността на line, където са правилата за този ред. В current записваме правилото, което отговаря на позивната и допълнителните ITU зона или WAZ зона, ако ги има, като първо проверяваме дали правилото е от тип 1 и ако не е( дължината на стринга в current е нула) проверяваме за правило от тип 2. След това в itu записваме само числото в [] скоби, ако ги има в current и в waz - числото в (), ако ги има в current. След това проверяваме стойностите на всяко едно и ако някое е празно, то тази зона не е била дефинирана в правилото и взимаме стойностите от пета и шеста колона за waz и itu, съответно. След това ги изписваме на stdout и изтриваме временния файл в променливата tempzones.
Ако имаме 4 позиционни аргумента по същия начин проверяваме за файла и позиционните, а за командата проверяваме дали е "distance". След като всичко е верифицирано, в line1 записваме резултата от find_line за callsign1(първата позивна) и в line2 записваме резултата от find_line за callsign2(втората позивна). Ако дължината на някоя от тях е нула извежда съобщението "no matches\n" на stderr и терминира програмата с exit code 1. Ако не е, в longtitude1 записваме средната географска дължина на първанта позивна, в longtitude2 - тази на втората. В latitude1 записваме средната географска ширина на първата позивна, а в latitude2 - тази на втората. Калкулираме разстоянието между приблизителните центрове на техните области по формулата - distance=arccos(sin(latitude1)*sin(latitude2)+cos(latitude1)*cos(latitude2)*cos(|longtitude1 - longtitude2|))*radius. radius е дефиниран в променливата RADIUS=6371. В променлиата sin1 e стойността на sin(latitude1), в sin2 е sin(latitude2),в cos1 еcos(latitude1),в cos2 е cos(latitude2). В dist е абсолютната разлика на дължините (|longtitude1 - longtitude2|) и в cos3 е cos(dist). В sum е стойността на sin1*sin2+cos1*cos2*cos3. В acos е arccos(sum) и в result е acos*RADIUS. С цел по-голяма точност всички изчисления се правят с десетични числа. Тъй като резултата трябва да е цяло число в integer_part е цялата част от резултата, а в  decimal_part - тази след десетичната запетая. Проверяваме последната и закръгляваме според нея. След това изписваме резултата, който се намира в променливата integer_part на stdout.
